namespace Daily_Algorithm._2025_10.day1027;
// 멀리 뛰기
// https://school.programmers.co.kr/learn/courses/30/lessons/12914

// 한번에 1칸, 또는 2칸
// 멀리뛰기에 사용될 칸의 수 n

// 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내,
// 여기에 1234567를 나눈 나머지를 리턴 <- 사악한 녀석

public class No07
{  
    public long solution(int n) {
        int[] dp = new int[n + 1];
        dp[0] = dp[1] = 1;

        for (int i = 2; i <= n; i++)
        {
            dp[i] += (dp[i - 1] + dp[i - 2]) % 1234567;
        }

        return dp[n];
    }
}

// [메모] 동적 계획법 DP
// 복잡한 문제를 작은 부분들로 나눠서 해결
// !! 핵심 -> 이미 계산된 값을 재사용해 중복 계산을 피하는 것 !!

// [메모] 점화식
// 문제 해결 규칙을 정의한 수식 
// DP에서 작은 부분에 공통적으로 적용되는 연산

// [메모] 이 문제의 점화식이 "dp[i] += dp[i - 1] + dp[i - 2]"인 이유
// 1 또는 2를 더해 n을 만드는 과정에서, 마지막에 더해지는 값은 무조건 1 또는 2임
// 마지막이 1인 경우의 수는 n-1 에서 1을 더하는 것이기 때문에, n-1을 만드는 경우의 수와 동일
// 마찬가지로 2인 경우의 수 역시 n-2를 만드는 경우의 수와 동일
// !! 즉, n을 만드는 경우의 수는 n-1을 만드는 경우의 수와 n-2를 만드는 경우의 수의 합과 같은 것 !!
// 따라서 dp 배열의 각 요소를 i를 만드는 경우의 수라 정의해 위의 점화식이 나온 것
