namespace Daily_Algorithm._2025_10.day1027;
// 피보나치 수
// https://school.programmers.co.kr/learn/courses/30/lessons/12945
public class No02
{  
   public int solution(int n) {  
        int f1 = 0;  
        int f2 = 1;  
        for (int i = 2; i <= n; i++)  
        {        
            int temp = f2;  
            f2 = (f1 + f2) % 1234567;  
            f1 = temp % 1234567;  
        }    
        return f2;  
   }
}

// [메모] 나머지 반환 문제 팁
// N으로 나눈 나머지를 반환하는 문제는 십중팔구 "int64도 버티지 못할만큼 숫자가 엄청 커지니까 적당히 나눠라"는 뉘앙스입니다.
// 중간에 모듈러 연산을 안해주면 일찍이 오버플로우가 발생했을테니 오답이죠.

// [메모] 모듈러 연산 법칙
/*
DP유형의 문제가 그런 경우가 많습니다.
중간에 숫자가 너무 커져버리는 문제인 경우에는, 숫자를 제한해야하기 때문에, 어쩔 수 없이 추가된 규칙이라고 볼 수 있습니다.
모듈러 연산은, 덧셈 / 뺄셈 / 곱셈에 대해서, 다음과 같은 특정 법칙이 성립됩니다.
(A + B) % C = (A % C + B % C) % C
(A - B) % C = (A % C - B % C) % C
(A * B) % C = (A % C * B % C) % C
이러한 법칙이 성립되므로, 매번 나오는 결과마다 나머지연산을 수행해도, 어차피 나오는 결론은 C보다 작은 값으로 같아지므로, 매번 수행하는 것이 맞습니다. 
이는 연산 중간에 수가 너무 커질 수 있으므로, 생기는 제약입니다. 
보통 일반적으로는, 결과만 물어보기 때문에 중간에 모듈러 연산을 수행하려고 하지 않는 것이 맞다고 생각할 수도 있습니다. 
하지만, 이런 제약 조건은 중간 연산 결과에도 자료형을 초과하는 큰 수가 되는 경우가 수시로 발생하기 때문에, 중간 과정에도 모듈러 연산을 반드시 수행하여야 합니다.
*/

